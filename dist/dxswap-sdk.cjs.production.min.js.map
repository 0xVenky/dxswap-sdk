{"version":3,"file":"dxswap-sdk.cjs.production.min.js","sources":["../src/constants.ts","../src/errors.ts","../src/utils.ts","../src/entities/token.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/pair.ts","../src/entities/fractions/price.ts","../src/entities/route.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/entities/fractions/percent.ts","../src/entities/trade.ts"],"sourcesContent":["import JSBI from 'jsbi'\nimport { proxies as kovanProxies } from 'dxswap-core/.openzeppelin/kovan.json'\n\n// exports for external consumption\nexport type BigintIsh = JSBI | bigint | string\n\nexport enum ChainId {\n  MAINNET = 1,\n  ROPSTEN = 3,\n  RINKEBY = 4,\n  GÖRLI = 5,\n  KOVAN = 42\n}\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\nexport const FACTORY_ADDRESS: { [chainId: number]: string } = {\n  [ChainId.MAINNET]: '0x0000000000000000000000000000000000000001',\n  [ChainId.ROPSTEN]: '0x0000000000000000000000000000000000000003',\n  [ChainId.RINKEBY]: '0x0000000000000000000000000000000000000004',\n  [ChainId.GÖRLI]: '0x0000000000000000000000000000000000000005',\n  [ChainId.KOVAN]: kovanProxies['dxswap-core/DXswapFactory'][0].address\n}\n\nexport const INIT_CODE_HASH = '0x25dd05d38222d917e4487e1da5be545f4c08adc197eb59f87c597a13cf7791d2'\n\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\n\n// exports for internal consumption\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\nexport const TWO = JSBI.BigInt(2)\nexport const THREE = JSBI.BigInt(3)\nexport const FIVE = JSBI.BigInt(5)\nexport const TEN = JSBI.BigInt(10)\nexport const _30 = JSBI.BigInt(30)\nexport const _100 = JSBI.BigInt(100)\nexport const _1000 = JSBI.BigInt(1000)\nexport const _10000 = JSBI.BigInt(10000)\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: JSBI.BigInt('0xff'),\n  [SolidityType.uint256]: JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}\n","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport JSBI from 'jsbi'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n    ? JSBI.BigInt(bigintIsh.toString())\n    : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { getNetwork } from '@ethersproject/networks'\nimport { getDefaultProvider } from '@ethersproject/providers'\nimport { Contract } from '@ethersproject/contracts'\n\nimport { ChainId, SolidityType } from '../constants'\nimport ERC20 from '../abis/ERC20.json'\nimport { validateAndParseAddress, validateSolidityTypeInstance } from '../utils'\n\nlet CACHE: { [chainId: number]: { [address: string]: number } } = {\n  [ChainId.MAINNET]: {\n    '0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A': 9 // DGD\n  }\n}\n\nexport class Token {\n  public readonly chainId: ChainId\n  public readonly address: string\n  public readonly decimals: number\n  public readonly symbol?: string\n  public readonly name?: string\n\n  static async fetchData(\n    chainId: ChainId,\n    address: string,\n    provider = getDefaultProvider(getNetwork(chainId)),\n    symbol?: string,\n    name?: string\n  ): Promise<Token> {\n    const parsedDecimals =\n      typeof CACHE?.[chainId]?.[address] === 'number'\n        ? CACHE[chainId][address]\n        : await new Contract(address, ERC20, provider).decimals().then((decimals: number): number => {\n            CACHE = {\n              ...CACHE,\n              [chainId]: {\n                ...CACHE?.[chainId],\n                [address]: decimals\n              }\n            }\n            return decimals\n          })\n    return new Token(chainId, address, parsedDecimals, symbol, name)\n  }\n\n  constructor(chainId: ChainId, address: string, decimals: number, symbol?: string, name?: string) {\n    validateSolidityTypeInstance(JSBI.BigInt(decimals), SolidityType.uint8)\n\n    this.chainId = chainId\n    this.address = validateAndParseAddress(address)\n    this.decimals = decimals\n    if (typeof symbol === 'string') this.symbol = symbol\n    if (typeof name === 'string') this.name = name\n  }\n\n  equals(other: Token): boolean {\n    const equal = this.chainId === other.chainId && this.address === other.address\n    if (equal) {\n      invariant(this.decimals === other.decimals, 'DECIMALS')\n      if (this.symbol && other.symbol) invariant(this.symbol === other.symbol, 'SYMBOL')\n      if (this.name && other.name) invariant(this.name === other.name, 'NAME')\n    }\n    return equal\n  }\n\n  sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n}\n\nexport const WETH = {\n  [ChainId.MAINNET]: new Token(\n    ChainId.MAINNET,\n    '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n    18,\n    'WETH',\n    'Wrapped Ether'\n  ),\n  [ChainId.ROPSTEN]: new Token(\n    ChainId.ROPSTEN,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped Ether'\n  ),\n  [ChainId.RINKEBY]: new Token(\n    ChainId.RINKEBY,\n    '0xc778417E063141139Fce010982780140Aa0cD5Ab',\n    18,\n    'WETH',\n    'Wrapped Ether'\n  ),\n  [ChainId.GÖRLI]: new Token(ChainId.GÖRLI, '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6', 18, 'WETH', 'Wrapped Ether'),\n  [ChainId.KOVAN]: new Token(ChainId.KOVAN, '0xd0A1E359811322d97991E03f863a0C30C2cF029C', 18, 'WETH', 'Wrapped Ether')\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding } from '../../constants'\nimport { ONE } from '../../constants'\nimport { parseBigintIsh } from '../../utils'\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: JSBI\n  public readonly denominator: JSBI\n\n  constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\n    this.numerator = parseBigintIsh(numerator)\n    this.denominator = parseBigintIsh(denominator)\n  }\n\n  // performs floor division\n  get quotient(): JSBI {\n    return JSBI.divide(this.numerator, this.denominator)\n  }\n\n  // remainder after floor division\n  get remainder(): Fraction {\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\n  }\n\n  invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.add(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.subtract(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.lessThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.equal(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.greaterThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.numerator),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(this.denominator, otherParsed.numerator)\n    )\n  }\n\n  toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding, TEN, SolidityType } from '../../constants'\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../utils'\nimport { Token } from '../token'\nimport { Fraction } from './fraction'\n\nconst Big = toFormat(_Big)\n\nexport class TokenAmount extends Fraction {\n  public readonly token: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  constructor(token: Token, amount: BigintIsh) {\n    const parsedAmount = parseBigintIsh(amount)\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\n\n    super(parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(token.decimals)))\n    this.token = token\n  }\n\n  get raw(): JSBI {\n    return this.numerator\n  }\n\n  add(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.add(this.raw, other.raw))\n  }\n\n  subtract(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.subtract(this.raw, other.raw))\n  }\n\n  toSignificant(significantDigits: number = 6, format?: object, rounding: Rounding = Rounding.ROUND_DOWN): string {\n    return super.toSignificant(significantDigits, format, rounding)\n  }\n\n  toFixed(\n    decimalPlaces: number = this.token.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.token.decimals, 'DECIMALS')\n    return super.toFixed(decimalPlaces, format, rounding)\n  }\n\n  toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.token.decimals\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { getNetwork } from '@ethersproject/networks'\nimport { getDefaultProvider } from '@ethersproject/providers'\nimport { Contract } from '@ethersproject/contracts'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS,\n  INIT_CODE_HASH,\n  MINIMUM_LIQUIDITY,\n  ZERO,\n  ONE,\n  FIVE,\n  _30,\n  _10000\n} from '../constants'\nimport IDXswapPair from 'dxswap-core/build/contracts/IDXswapPair.json'\nimport IDXswapFactory from 'dxswap-core/build/contracts/IDXswapFactory.json'\nimport { sqrt, parseBigintIsh } from '../utils'\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\nimport { Token } from './token'\nimport { TokenAmount } from './fractions/tokenAmount'\n\nlet CACHE: { [token0Address: string]: { [token1Address: string]: string } } = {}\n\nexport class Pair {\n  public readonly liquidityToken: Token\n  private readonly tokenAmounts: [TokenAmount, TokenAmount]\n  public readonly swapFee: Promise<BigintIsh>\n  public readonly protocolFeeDenominator: Promise<BigintIsh>\n\n\n  static getAddress(tokenA: Token, tokenB: Token): string {\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n    if (CACHE?.[tokens[0].address]?.[tokens[1].address] === undefined) {\n      CACHE = {\n        ...CACHE,\n        [tokens[0].address]: {\n          ...CACHE?.[tokens[0].address],\n          [tokens[1].address]: getCreate2Address(\n            FACTORY_ADDRESS[tokenA.chainId],\n            keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]),\n            INIT_CODE_HASH\n          )\n        }\n      }\n    }\n\n    return CACHE[tokens[0].address][tokens[1].address]\n  }\n\n  static async fetchData(\n    tokenA: Token,\n    tokenB: Token,\n    provider = getDefaultProvider(getNetwork(tokenA.chainId))\n  ): Promise<Pair> {\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\n    const address = Pair.getAddress(tokenA, tokenB)\n    const [reserves0, reserves1] = await new Contract(address, IDXswapPair.abi, provider).getReserves()\n    const balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0]\n    return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]))\n  }\n\n  constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\n    invariant(tokenAmountA.token.chainId === tokenAmountB.token.chainId, 'CHAIN_ID')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].token.chainId,\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\n      18,\n      'DXS',\n      'DXswap'\n    )\n    this.swapFee = new Contract(\n      this.liquidityToken.address, IDXswapPair.abi, getDefaultProvider(getNetwork(tokenAmountA.token.chainId))\n    ).swapFee().catch(() => { return _30 })\n    this.protocolFeeDenominator = new Contract(\n      FACTORY_ADDRESS[tokenAmountA.token.chainId],\n      IDXswapFactory.abi,\n      getDefaultProvider(getNetwork(tokenAmountA.token.chainId))\n    ).protocolFeeDenominator().catch(() => { return FIVE })\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\n  }\n\n  get token0(): Token {\n    return this.tokenAmounts[0].token\n  }\n\n  get token1(): Token {\n    return this.tokenAmounts[1].token\n  }\n\n  get reserve0(): TokenAmount {\n    return this.tokenAmounts[0]\n  }\n\n  get reserve1(): TokenAmount {\n    return this.tokenAmounts[1]\n  }\n\n  reserveOf(token: Token): TokenAmount {\n    invariant(token.equals(this.token0) || token.equals(this.token1), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  async getOutputAmount(inputAmount: TokenAmount): Promise<[TokenAmount, Pair]> {\n    invariant(inputAmount.token.equals(this.token0) || inputAmount.token.equals(this.token1), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.token)\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, JSBI.subtract(_10000, parseBigintIsh(await this.swapFee)))\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, _10000), inputAmountWithFee)\n    const outputAmount = new TokenAmount(\n      inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  async getInputAmount(outputAmount: TokenAmount): Promise<[TokenAmount, Pair]> {\n    invariant(outputAmount.token.equals(this.token0) || outputAmount.token.equals(this.token1), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.raw, ZERO) ||\n      JSBI.equal(this.reserve1.raw, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.token)\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), _10000)\n    const denominator = JSBI.multiply(\n      JSBI.subtract(outputReserve.raw, outputAmount.raw), JSBI.subtract(_10000, parseBigintIsh(await this.swapFee))\n    )\n    const inputAmount = new TokenAmount(\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  getLiquidityMinted(totalSupply: TokenAmount, tokenAmountA: TokenAmount, tokenAmountB: TokenAmount): TokenAmount {\n    invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return new TokenAmount(this.liquidityToken, liquidity)\n  }\n\n  async getLiquidityValue(\n    token: Token,\n    totalSupply: TokenAmount,\n    liquidity: TokenAmount,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): Promise<TokenAmount> {\n    invariant(token.equals(this.token0) || token.equals(this.token1), 'TOKEN')\n    invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: TokenAmount\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      invariant(!!kLast, 'K_LAST')\n      const kLastParsed = parseBigintIsh(kLast as any)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, parseBigintIsh(await this.protocolFeeDenominator)), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return new TokenAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n    )\n  }\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\n\nimport { BigintIsh, Rounding, TEN } from '../../constants'\nimport { Token } from '../token'\nimport { Route } from '../route'\nimport { Fraction } from './fraction'\nimport { TokenAmount } from './tokenAmount'\n\nexport class Price extends Fraction {\n  public readonly baseToken: Token // input i.e. denominator\n  public readonly quoteToken: Token // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n  static fromRoute(route: Route): Price {\n    const prices: Price[] = []\n    for (const [i, pair] of route.pairs.entries()) {\n      prices.push(\n        route.path[i].equals(pair.token0)\n          ? new Price(pair.reserve0.token, pair.reserve1.token, pair.reserve0.raw, pair.reserve1.raw)\n          : new Price(pair.reserve1.token, pair.reserve0.token, pair.reserve1.raw, pair.reserve0.raw)\n      )\n    }\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  constructor(baseToken: Token, quoteToken: Token, denominator: BigintIsh, numerator: BigintIsh) {\n    super(numerator, denominator)\n\n    this.baseToken = baseToken\n    this.quoteToken = quoteToken\n    this.scalar = new Fraction(\n      JSBI.exponentiate(TEN, JSBI.BigInt(baseToken.decimals)),\n      JSBI.exponentiate(TEN, JSBI.BigInt(quoteToken.decimals))\n    )\n  }\n\n  get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n\n  get adjusted(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  invert(): Price {\n    return new Price(this.quoteToken, this.baseToken, this.numerator, this.denominator)\n  }\n\n  multiply(other: Price): Price {\n    invariant(this.quoteToken.equals(other.baseToken), 'BASE')\n    const fraction = super.multiply(other)\n    return new Price(this.baseToken, other.quoteToken, fraction.denominator, fraction.numerator)\n  }\n\n  // performs floor division on overflow\n  quote(tokenAmount: TokenAmount): TokenAmount {\n    invariant(tokenAmount.token.equals(this.baseToken), 'TOKEN')\n    return new TokenAmount(this.quoteToken, super.multiply(tokenAmount.raw).quotient)\n  }\n\n  toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\n  }\n\n  toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { Token } from './token'\nimport { Pair } from './pair'\nimport { Price } from './fractions/price'\n\nexport class Route {\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly midPrice: Price\n\n  constructor(pairs: Pair[], input: Token) {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(\n      pairs.map(pair => pair.token0.chainId === pairs[0].token0.chainId).every(x => x),\n      'CHAIN_IDS'\n    )\n    const path = [input]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n    invariant(path.length === new Set(path).size, 'PATH')\n\n    this.pairs = pairs\n    this.path = path\n    this.midPrice = Price.fromRoute(this)\n  }\n\n  get input(): Token {\n    return this.path[0]\n  }\n\n  get output(): Token {\n    return this.path[this.path.length - 1]\n  }\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Rounding, _100 } from '../../constants'\nimport { Fraction } from './fraction'\n\nconst _100_PERCENT = new Fraction(_100)\n\nexport class Percent extends Fraction {\n  toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\n  }\n\n  toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { Token } from 'entities/token'\nimport invariant from 'tiny-invariant'\n\nimport { ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Fraction, TokenAmount } from './fractions'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { Pair } from './pair'\nimport { Route } from './route'\n\nfunction getSlippage(midPrice: Price, inputAmount: TokenAmount, outputAmount: TokenAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// minimal interface so the input output comparator may be shared across types\ninterface InputOutput {\n  readonly inputAmount?: TokenAmount\n  readonly outputAmount?: TokenAmount\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(a.inputAmount !== undefined && a.outputAmount !== undefined, 'UNDEFINED_A')\n  invariant(b.inputAmount !== undefined && b.outputAmount !== undefined, 'UNDEFINED_B')\n  \n  invariant(a.inputAmount.token.equals(b.inputAmount.token), 'INPUT_TOKEN')\n  invariant(a.outputAmount.token.equals(b.outputAmount.token), 'OUTPUT_TOKEN')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Trade, b: Trade) {\n  invariant(a.slippage !== undefined && b.slippage !== undefined, 'UNDEFINED_NULL')\n  invariant(a.route !== undefined && b.route !== undefined, 'UNDEFINED_NULL')\n\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.slippage.lessThan(b.slippage)) {\n    return -1\n  } else if (a.slippage.greaterThan(b.slippage)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\nexport class Trade {\n  public route?: Route\n  public tradeType?: TradeType\n  public amount?: TokenAmount\n  public inputAmount?: TokenAmount\n  public outputAmount?: TokenAmount\n  public executionPrice?: Price\n  public nextMidPrice?: Price\n  public slippage?: Percent\n  \n  public create = async (route: Route, amount: TokenAmount, tradeType: TradeType) => {\n    invariant(amount.token.equals(tradeType === TradeType.EXACT_INPUT ? route.input : route.output), 'TOKEN')\n    let trade = new Trade()\n    trade.route = route\n    trade.tradeType = tradeType\n    trade.amount = amount\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextPairs: Pair[] = new Array(route.pairs.length)\n\n    if (tradeType === TradeType.EXACT_INPUT) {\n      amounts[0] = trade.amount\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount, nextPair] = await pair.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n        nextPairs[i] = nextPair\n      }\n    } else {\n      amounts[amounts.length - 1] = trade.amount\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount, nextPair] = await pair.getInputAmount(amounts[i])\n        amounts[i - 1] = inputAmount\n        nextPairs[i - 1] = nextPair\n      }\n    }\n\n    trade.route = route\n    trade.tradeType = tradeType\n    const inputAmount = amounts[0]\n    const outputAmount = amounts[amounts.length - 1]\n    trade.inputAmount = inputAmount\n    trade.outputAmount = outputAmount\n    trade.executionPrice = new Price(route.input, route.output, inputAmount.raw, outputAmount.raw)\n    trade.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\n    trade.slippage = getSlippage(route.midPrice, inputAmount, outputAmount)\n    \n    return trade;\n  }\n\n  // get the minimum amount that must be received from this trade for the given slippage tolerance\n  public minimumAmountOut(slippageTolerance: Percent): TokenAmount | undefined {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    invariant(this.outputAmount !== undefined)\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      return new TokenAmount(\n        this.outputAmount.token,\n        new Fraction(ONE)\n          .add(slippageTolerance)\n          .invert()\n          .multiply(this.outputAmount.raw).quotient\n      )\n    }\n  }\n\n  // get the maximum amount in that can be spent via this trade for the given slippage tolerance\n  public maximumAmountIn(slippageTolerance: Percent): TokenAmount | undefined {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    invariant(this.inputAmount !== undefined)\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      return new TokenAmount(\n        this.inputAmount.token,\n        new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      )\n    }\n  }\n\n  // given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n  // amount to an output token, making at most `maxHops` hops\n  // note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n  // the amount in among multiple routes.\n  public static async bestTradeExactIn(\n    pairs: Pair[],\n    amountIn: TokenAmount,\n    tokenOut: Token,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountIn: TokenAmount = amountIn,\n    bestTrades: Trade[] = []\n  ): Promise<Trade[]> {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountIn === amountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        ;[amountOut] = await pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if (error.isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut!.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          await new Trade().create(\n            new Route([...currentPairs, pair], originalAmountIn.token),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        await Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          amountOut!,\n          tokenOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  // similar to the above method but instead targets a fixed output amount\n  // given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n  // to an output token amount, making at most `maxHops` hops\n  // note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n  // the amount in among multiple routes.\n  public static async bestTradeExactOut(\n    pairs: Pair[],\n    tokenIn: Token,\n    amountOut: TokenAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountOut: TokenAmount = amountOut,\n    bestTrades: Trade[] = []\n  ): Promise<Trade[]> {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountOut === amountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        ;[amountIn] = await pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (error.isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn!.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          await new Trade().create(\n            new Route([pair, ...currentPairs], tokenIn),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        await Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          tokenIn,\n          amountIn!,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n"],"names":["ChainId","TradeType","Rounding","SolidityType","FACTORY_ADDRESS","MAINNET","ROPSTEN","RINKEBY","GÖRLI","KOVAN","kovanProxies","address","INIT_CODE_HASH","MINIMUM_LIQUIDITY","JSBI","BigInt","ZERO","ONE","TWO","THREE","FIVE","TEN","_30","_100","_10000","SOLIDITY_TYPE_MAXIMA","uint8","uint256","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","name","_this","constructor","setPrototypeOf","prototype","Error","InsufficientInputAmountError","_this2","validateSolidityTypeInstance","value","solidityType","greaterThanOrEqual","invariant","lessThanOrEqual","validateAndParseAddress","getAddress","error","parseBigintIsh","bigintIsh","toString","sqrt","y","x","z","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop","CACHE","Token","chainId","decimals","symbol","this","fetchData","provider","parsedDecimals","getDefaultProvider","getNetwork","_CACHE2","_CACHE2$chainId","Contract","ERC20","then","_CACHE3","equals","other","equal","sortsBefore","toLowerCase","WETH","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","Fraction","numerator","denominator","invert","otherParsed","multiply","subtract","equalTo","toSignificant","significantDigits","format","rounding","groupSeparator","Number","isInteger","set","precision","quotient","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","remainder","TokenAmount","token","amount","parsedAmount","exponentiate","raw","toExact","Pair","tokenAmountA","tokenAmountB","tokenAmounts","liquidityToken","swapFee","IDXswapPair","abi","protocolFeeDenominator","IDXswapFactory","tokenA","tokenB","tokens","undefined","getCreate2Address","keccak256","pack","getReserves","reserves0","reserves1","balances","reserveOf","token0","token1","reserve0","reserve1","getOutputAmount","inputAmount","inputReserve","outputReserve","inputAmountWithFee","outputAmount","getInputAmount","_this4","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","_this6","kLastParsed","rootK","rootKLast","feeLiquidity","Price","baseToken","quoteToken","scalar","fromRoute","route","prices","pairs","entries","pair","path","slice","reduce","accumulator","currentValue","fraction","quote","tokenAmount","_Fraction","adjusted","Route","input","map","every","currentInput","output","Set","size","midPrice","_Pact","onFulfilled","onRejected","result","state","s","callback","_settle","v","e","o","pact","bind","observer","_isSettledPact","thenable","_forTo","array","body","check","reject","i","_cycle","_for","test","update","stage","shouldContinue","updateValue","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","_catch","recover","Symbol","iterator","asyncIterator","_100_PERCENT","Percent","inputOutputComparator","a","b","tradeComparator","slippage","ioComp","Trade","tradeType","trade","amounts","executionPrice","nextMidPrice","nextPairs","exactQuote","getSlippage","EXACT_INPUT","Array","nextPair","minimumAmountOut","slippageTolerance","EXACT_OUTPUT","maximumAmountIn","bestTradeExactIn","amountIn","tokenOut","currentPairs","originalAmountIn","bestTrades","maxNumResults","maxHops","amountOut","create","pairsExcludingThisPair","concat","isInsufficientInputAmountError","bestTradeExactOut","tokenIn","originalAmountOut","isInsufficientReservesError"],"mappings":"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"}